Tip:
If accidentally creating a 3D project:
	- Change camera to orthographic
	- Camera -> Clear flags: From Skybox to Solid Colour
	- In the Scene toolbar, to the right of Audio: "Toggle Skybox, fog and various effects"
	- Package Manager, install:
		- 2D Sprite
		- Input system
		- TextMeshPro
		
Customizing dockable pane layout:
- arrange panes as wanted
- In the layout droplist at the far top-right: Save etc.
- In the Game view: Create 9:16 (aspect ratio)


- Download asset pack from kenney.nl: Space Shooter Redux
- Copy into assets folder
- Note: If starting with a 3D project, Texture Type must be changed from "Default" to "Sprite (2D and UI)" for all images

Create "Player" game object
	- Choose a player ship from asset pack and drag it on to the player object
	- Create prefabs folder
	- Prefab player
Create "enemy" game object
	- Choose a player ship from asset pack and drag it on to the player object
	- Choose an enemy ship from asset pack and drag it on to the game object
	- Prefab enemy
	
- The game objects look too big on in the game view
	=> Increase Camera size. 9 looks OK.
	
Set up background
	- Download starfield from course
	- Put in assets pack
	- Create new game object: Background
	- Drag background sprite onto object
	- To make sure game objects visible: On starfield sprite, set Order in Layer: -1
	
Unity Input System:
	- Add component on Player: Player Input
	- Click "Create Actions" (name it InputActions)
	- Double-click the asset to see its settings
	- Drag the input actions asset to the Player Input component
	- On Player Input component: Click "Open Input Settings" -> Click Create Settings Asset
	- Create Player script
		- Using UnityEngine.InputSystem
		- Implement OnMove(InputValue value)  -> value.Get<Vector2>()
		- Make movement frame-rate independent, use Time.deltaTime (deltaTime is the time it took to render the last frame)
			Vector3 delta = m_rawInput * m_moveSpeed * Time.deltaTime
		
Confine player to screen boundaries:
	- ViewPortToWorldPoint: Converts a normalized position on the screen to a 3D pos in world space
	- Normalized screen coords: Lower-left corresponds to (0,0), upper right to (1,1)
	
Enemies:
	- WaveConfig file:
		- Which enemies are spawned
		- The path to follow
		- Time between enemy spawns
	- Create empty game object: Path 0
		- Create child game object: Waypoint (0)
		- Select an icon for the Waypoint in order to see it, at the top left in the inspector
		- Duplicate 4 times
		- Update coordinates of the 5 objects to create a path
		- Prefab into Waves and Paths folder
		- Create script: WaveConfigSO. Derives from ScriptableObject
		- In order to create from Unity:
			[CreateAssetMenu(menuName = "Wave Config", fileName = "New Wave Config")]
		- Implemenmt path getters
	- New script: Pathfinder. Attach to Enemy prefab	
		 Set enemy to first waypoint and iteratively move it
		- Use Vector2.MoveTowards to move towards the next waypoint in the list
		- In Waves and Paths folder, create a new Wave config (Wave 0) via popup (under Create)
		- Attach Path 0 prefab to its path prefab field
		- On enemy prefab, attach the new wave config to it
	- Instantiate enemies into the scene:
		- WaveConfigSO: Maintain list of enemies in a list + create getters
		- New script, EnemySpawner. Instatiates enemies kept in WaveConfigSO.
		- Refactor Pathfinder script to fetch WaveConfigSO from enemySpawner instead of maintaining via SerializeField
		- Create EnemySpawner game object
			- Add EnemySpawner script
			- Connect Wave 0 to it
		- Select Wave 0
		- Drag enemy 0 prefab over to its "Enemy prefabs" list
		- Delete enemies from scene, will be generated runtime	
		- Nesting instatiated enemies inside enemySpawner:
			Add this.transform param to Instantiate() method
	- Make enemies spawn at diffent intervals:
		- WaveConfigSO.GetRandomSpawnTime:
			Random.Range(m_timeBetweenEnemySpawns - m_spawnTimeVariance,
			m_timeBetweenEnemySpawns + m_spawnTimeVariance);
		  return Mathf.Clamp(spawnTime, m_minimumSpawnTime, float.MaxValue);
		- EnemySpawner.SpawnEnemies: Make this function a coroutine
			for (int i = 0; i < m_currentWave.GetEnemyCount(); i++)
			{
				Instantiate(m_currentWave.GetEnemyPrefab(i), m_currentWave.GetStartingWaypoint().position, Quaternion.identity, transform);
				yield return new WaitForSeconds(m_currentWave.GetRandomSpawnTime());
			}
	- Several enemy waves:
		- EnemySpawner: List of WaveConfigSO
		- EnemySpawner.SpawnEnemies: Loop through each wave and that wave's enemies
		- Select EnemySpawner: Drag Wave 0 and Wave 1 into the list in the inspector
		- Set up Wave 1

Taking damage:
	- Select both enemy and player prefabs:
		- Add RigidBody2D
		- Body Type -> Kinematic (because objects are moved via code instead of the physics system)
		- Add Circle Collider 2D
		- Edit circle collider on both objects
		- Set trigger
		- Create new script: Health, attach to both enemy and player
		- Create new script: DamageDealer
		- DamageDealer: Hold the amount of damage attached object can dockable
		- Health: The amount of healt the attached object has
		- Enemy: Add DamageDealer
		
Projectile setup:
	- Create empty game object: Projectile
	- Locate a laser PNG and drag it below the Projectile object
	- Scale it to (2,2,2)
	- Add RigidBody2D. Type: Kinematic
	- Add CapsuleCollider2D. Edit collider. (Press ALT while dragging to move both sides of collider)
	- CapsuleCollider2D: Is Trigger
	- Add DamageDealer
	- Rename: Projectile_Player
	- Duplicate it => Projectile_Enemy
	- Projectile_Enemy: Change sprite, red laser
	- Problem: Projectile_Player can hit and damage player
		- Set up two new layers: Player and Enemy
		- Enemy and Projectile_Enemy: Set Enemy layer
		- Player and Projectile_Player: Set Player layer
		- Project Settings -> Physics 2D -> Layer Collision Matrix
	- Projectiles should appear under ships => Order in Layer: 0
		Player and Enemy: Order in Layer: 1
	- Double-click Input System in project
		- Add new key for firing: Space
		- Click '+' on the fire actions -> Add Binding. This adds a blank binding
			- Click "path" -> Listen -> Press SpaceBar
			- Tick use in control scheme "Keyboard & Mouse"
		- Select Fire action.
			- Change Action Type from Button to Value. Control Type -> Any.
			- This is needed to know when to start firing (keydown) and stop (keyup)			
		- Click "Save Asset"
		
Player Shooting:
	- Player script: OnFire input notification
	- Player: Add Shooter script
		- GameObject projectilePrefab
	- Get reference to Shooter in Player script via GetComponent<Shooter>
	- Player.OnFire
	        if (m_shooter)
				m_shooter.m_isFiring = value.isPressed;
	- Shooter:
		Fire:
			StartCoroutine(FireContinuously());
		
		IEnumerator FireContinuously()
			GameObject projectile = Instantiate(m_projectilePrefab, transform.position, Quaternion.identity);
            Rigidbody2D rigidBody = projectile.GetComponent<Rigidbody2D>();
            if (rigidBody != null)
                rigidBody.velocity = transform.up * m_projectileSpeed;
Enemy Shooting:
	- Enemy prefab: Add Shooter script. Attach enemy projectile
	- Should always fire => In Shooter script:
		[SerializeField] bool m_useAI = false;
	- Initially, enemy shoots downwards => Rotate sprite 180 degrees, so that up-vector points down
	- EnemySpawner: Rotate 180 degrees when instantiating:
		Instantiate(m_currentWave.GetEnemyPrefab(i), m_currentWave.GetStartingWaypoint().position, Quaternion.Euler(0, 0, 180), transform);
	- Random time between shots:
            float timeToNextProjectile = Random.Range(m_firingRate - m_firingRateVariance, m_firingRate + m_firingRateVariance);
            Mathf.Clamp(timeToNextProjectile, m_minimumFiringRate, float.MaxValue);
	- Group serialized fields in a script:
		[Header("General")]
	- Hide public members:
		[HideInInspector]
	
Particle Effects:
	- In hierarchy: Effects -> Particle System