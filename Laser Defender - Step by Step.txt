Intellisense not working?
	- Edit -> Preferences -> External Tools
		- Editor: Visual Studio Code
		- Tick Embedded packages
		- Tick Local packages
		- Click "Regenerate project files"


Web resources:
-------------
- kenney.nl
- OpenGameArt.org

-----
-----
Tip:
If accidentally creating a 3D project:
	- Change camera to orthographic
	- Camera -> Clear flags: From Skybox to Solid Colour
	- In the Scene toolbar, to the right of Audio: "Toggle Skybox, fog and various effects"
	- Package Manager, install:
		- 2D Sprite
		- Input system
		- TextMeshPro
		
Customizing dockable pane layout:
- arrange panes as wanted
- In the layout droplist at the far top-right: Save etc.
- In the Game view: Create 9:16 (aspect ratio)


- Download asset pack from kenney.nl: Space Shooter Redux
- Copy into assets folder
- Note: If starting with a 3D project, Texture Type must be changed from "Default" to "Sprite (2D and UI)" for all images

Create "Player" game object
	- Choose a player ship from asset pack and drag it on to the player object
	- Create prefabs folder
	- Prefab player
Create "enemy" game object
	- Choose a player ship from asset pack and drag it on to the player object
	- Choose an enemy ship from asset pack and drag it on to the game object
	- Prefab enemy
	
- The game objects look too big on in the game view
	=> Increase Camera size. 9 looks OK.
	
Set up background
	- Download starfield from course
	- Put in assets pack
	- Create new game object: Background
	- Drag background sprite onto object
	- To make sure game objects visible: On starfield sprite, set Order in Layer: -1
	
Unity Input System:
	- Add component on Player: Player Input
	- Click "Create Actions" (name it InputActions)
	- Double-click the asset to see its settings
	- Drag the input actions asset to the Player Input component
	- On Player Input component: Click "Open Input Settings" -> Click Create Settings Asset
	- Create Player script
		- Using UnityEngine.InputSystem
		- Implement OnMove(InputValue value)  -> value.Get<Vector2>()
		- Make movement frame-rate independent, use Time.deltaTime (deltaTime is the time it took to render the last frame)
			Vector3 delta = m_rawInput * m_moveSpeed * Time.deltaTime
		
Confine player to screen boundaries:
	- ViewPortToWorldPoint: Converts a normalized position on the screen to a 3D pos in world space
	- Normalized screen coords: Lower-left corresponds to (0,0), upper right to (1,1)
	
Enemies:
	- WaveConfig file:
		- Which enemies are spawned
		- The path to follow
		- Time between enemy spawns
	- Create empty game object: Path 0
		- Create child game object: Waypoint (0)
		- Select an icon for the Waypoint in order to see it, at the top left in the inspector
		- Duplicate 4 times
		- Update coordinates of the 5 objects to create a path
		- Prefab into Waves and Paths folder
		- Create script: WaveConfigSO. Derives from ScriptableObject
		- In order to create from Unity:
			[CreateAssetMenu(menuName = "Wave Config", fileName = "New Wave Config")]
		- Implemenmt path getters
	- New script: Pathfinder. Attach to Enemy prefab	
		 Set enemy to first waypoint and iteratively move it
		- Use Vector2.MoveTowards to move towards the next waypoint in the list
		- In Waves and Paths folder, create a new Wave config (Wave 0) via popup (under Create)
		- Attach Path 0 prefab to its path prefab field
		- On enemy prefab, attach the new wave config to it
	- Instantiate enemies into the scene:
		- WaveConfigSO: Maintain list of enemies in a list + create getters
		- New script, EnemySpawner. Instatiates enemies kept in WaveConfigSO.
		- Refactor Pathfinder script to fetch WaveConfigSO from enemySpawner instead of maintaining via SerializeField
		- Create EnemySpawner game object
			- Add EnemySpawner script
			- Connect Wave 0 to it
		- Select Wave 0
		- Drag enemy 0 prefab over to its "Enemy prefabs" list
		- Delete enemies from scene, will be generated runtime	
		- Nesting instatiated enemies inside enemySpawner:
			Add this.transform param to Instantiate() method
	- Make enemies spawn at diffent intervals:
		- WaveConfigSO.GetRandomSpawnTime:
			Random.Range(m_timeBetweenEnemySpawns - m_spawnTimeVariance,
			m_timeBetweenEnemySpawns + m_spawnTimeVariance);
		  return Mathf.Clamp(spawnTime, m_minimumSpawnTime, float.MaxValue);
		- EnemySpawner.SpawnEnemies: Make this function a coroutine
			for (int i = 0; i < m_currentWave.GetEnemyCount(); i++)
			{
				Instantiate(m_currentWave.GetEnemyPrefab(i), m_currentWave.GetStartingWaypoint().position, Quaternion.identity, transform);
				yield return new WaitForSeconds(m_currentWave.GetRandomSpawnTime());
			}
	- Several enemy waves:
		- EnemySpawner: List of WaveConfigSO
		- EnemySpawner.SpawnEnemies: Loop through each wave and that wave's enemies
		- Select EnemySpawner: Drag Wave 0 and Wave 1 into the list in the inspector
		- Set up Wave 1

Taking damage:
	- Select both enemy and player prefabs:
		- Add RigidBody2D
		- Body Type -> Kinematic (because objects are moved via code instead of the physics system)
		- Add Circle Collider 2D
		- Edit circle collider on both objects
		- Set trigger
		- Create new script: Health, attach to both enemy and player
		- Create new script: DamageDealer
		- DamageDealer: Hold the amount of damage attached object can dockable
		- Health: The amount of health the attached object has
		- Enemy: Add DamageDealer
		
Projectile setup:
	- Create empty game object: Projectile
	- Locate a laser PNG and drag it below the Projectile object
	- Scale it to (2,2,2)
	- Add RigidBody2D. Type: Kinematic
	- Add CapsuleCollider2D. Edit collider. (Press ALT while dragging to move both sides of collider)
	- CapsuleCollider2D: Is Trigger
	- Add DamageDealer
	- Rename: Projectile_Player
	- Duplicate it => Projectile_Enemy
	- Projectile_Enemy: Change sprite, red laser
	- Problem: Projectile_Player can hit and damage player
		- Set up two new layers: Player and Enemy
		- Enemy and Projectile_Enemy: Set Enemy layer
		- Player and Projectile_Player: Set Player layer
		- Project Settings -> Physics 2D -> Layer Collision Matrix
	- Projectiles should appear under ships => Order in Layer: 0
		Player and Enemy: Order in Layer: 1
	- Double-click Input System in project
		- Add new key for firing: Space
		- Click '+' on the fire actions -> Add Binding. This adds a blank binding
			- Click "path" -> Listen -> Press SpaceBar
			- Tick use in control scheme "Keyboard & Mouse"
		- Select Fire action.
			- Change Action Type from Button to Value. Control Type -> Any.
			- This is needed to know when to start firing (keydown) and stop (keyup)			
		- Click "Save Asset"
		
Player Shooting:
	- Player script: OnFire input notification
	- Player: Add Shooter script
		- GameObject projectilePrefab
	- Get reference to Shooter in Player script via GetComponent<Shooter>
	- Player.OnFire
	        if (m_shooter)
				m_shooter.m_isFiring = value.isPressed;
	- Shooter:
		Fire:
			StartCoroutine(FireContinuously());
		
		IEnumerator FireContinuously()
			GameObject projectile = Instantiate(m_projectilePrefab, transform.position, Quaternion.identity);
            Rigidbody2D rigidBody = projectile.GetComponent<Rigidbody2D>();
            if (rigidBody != null)
                rigidBody.velocity = transform.up * m_projectileSpeed;
Enemy Shooting:
	- Enemy prefab: Add Shooter script. Attach enemy projectile
	- Should always fire => In Shooter script:
		[SerializeField] bool m_useAI = false;
	- Initially, enemy shoots downwards => Rotate sprite 180 degrees, so that up-vector points down
	- EnemySpawner: Rotate 180 degrees when instantiating:
		Instantiate(m_currentWave.GetEnemyPrefab(i), m_currentWave.GetStartingWaypoint().position, Quaternion.Euler(0, 0, 180), transform);
	- Random time between shots:
            float timeToNextProjectile = Random.Range(m_firingRate - m_firingRateVariance, m_firingRate + m_firingRateVariance);
            Mathf.Clamp(timeToNextProjectile, m_minimumFiringRate, float.MaxValue);
	- Group serialized fields in a script:
		[Header("General")]
	- Hide public members:
		[HideInInspector]
	
Particle Effects:
	- In hierarchy: Effects -> Particle System
	- Create material in assets folder: m_explosion.
		- Change Shader: Particles -> Standard Unlit
		- Rendering Mode: Additive
		- Drag explosion PNG next to "Albedo" within Maps
	- Particle System -> Renderer: Drag our material into the material slot
	- Want to loop through each image within the sprite sheet:
		- Check Texture Sheet Animation
		- Tiles: 3, 1 (Sprite sheet is 3 by 1)
		- Cycles: 2 (i.e. loop through twice)
		- Start Frame: Random between two constants: 0, 2
	- Select and tick "Color over lifetime":
		- Select Color
			- Top: Alpha 
			- Bottom: Color 
			- Click anywhere to set up a new transition during the lifetime
	- Select Shape:
		- Change to Circle
		- Initially, it appears flat because it's in 3D => Reset particle system rotation
		- Also reset pos and scale
	- Constrain explosion:
		- Start lifetime: Random between two constants: 0.1 - 0.5
		- Start rotation: Random between two constants: 0 - 359
		- Rotation over lifetime: Angular velocity: 180 (rotation while travelling)
	- Emission -> Rate over time: 100
	- Shape -> Radius: 0.5
	- Size over lifetime: Flip default curve, so that particles start big and then decrease
	- Start Speed: 
		- Random between two constants: 0 - 2
		- Not optimal => Select Curve: Start at 0, end at 2: Several particles created with start speed 2 and gradually fewer towards 0
	- Switch off looping
	- Decrease Duration to 0.2
	- Prefab it as ExplosionEffect
	- In Health script:
		- [SerializeField] ParticleSystem m_hitEffect;
		- Introduce PlayHitEffect()
	- Particle effect is below the player/enemy => Change order in layer to 2 in "Renderer"
		
Screen Shake:
	- New script: CameraShake
	- Shake coroutine:
        while (elapsedTime < m_shakeDuration)
        {
            transform.position = m_initialPosition + (Vector3)Random.insideUnitCircle * m_shakeMagnitude;
            elapsedTime += Time.deltaTime;
            yield return new WaitForEndOfFrame();
        }	
	- Call it from the health script:
		Awake:
			m_cameraShake = Camera.main.GetComponent<CameraShake>();
		ShakeCamera:
			m_cameraShake.Play();
	- Tick "apply camera shake" on Player prefab
	- Reduce screen shake parameters on Camera: 0.5 duration, magnitude: 0.25
	
Scrolling Background:
	- Import 2 PNGs (Stars_0 and Stars_1) to be layered on top of each other
	- Drag both on to the background node
	- Update order in layer to ensure no visibility issues:
		- Stars_0 -> -2
		- Stars_1 -> -1
	- In assets folder, create new material: Background
	- Change Shader: Unlit -> Transparent
	- Drag this material onto both Stars_0 and Stars_1
	- Select both Stars_0 and Stars_1: Change texture wrap mode: Repeat + Apply
	- Create new script, SpriteScroller
	- Add script to Stars_0 and Stars_1 sprites
		- [SerializeField] Vector2 m_moveSpeed;
		- Update():
			m_offset = m_moveSpeed * Time.deltaTime;
			m_material.mainTextureOffset += m_offset;
	
Sound Effects:
	- Download from kenney.nl: Assets -> Audio -> Sci-fi sounds
	- Create AudioPlayer game object
	- Create new script, AudioPlayer, and attach to the game object
		- Range can be used to constrain a value:
			[SerializeField] [Range(0,1f)] float m_shootingVolume = 1f;
	- Shooter: Grab reference to AudioPlayer and call PlayShootingClip() when firing
	
Background music:
	- OpenGameArt.org
	- AudioListener, AudioSource, AudioFile 
	- On AudioPlayer game object: Add AudioSource component
		- Add music clip from OpenGameArt to AudioSource (AudioClip)
		- Tick "play on awake" and "loop"
		
Keeping Score:
	- Add ScoreKeeper game object and corresponding script
	- ScoreKeeper script:
		- holds score
		- public setter and getter
	- Health script:
		- Get ScoreKeeper ref
		- bool to differentiate whether health script is attached to player or enemy
		- When the game object is destroyed: Add score if it's attached to an enemy
		
UI - controls:
	- Add canvas: UI -> Canvas
	- Click on EventSystem node, see a warning: Click "replace with InputSystemUIInputModule"
	- Select Canvas:
		- Canvas Scaler: Change to "Scale with screen size"	
		- Change reference resolution: 1080 z 1920
	- Add panel: Right-click on canvas: UI -> Panel
		- Choose suitable colour for the panel
	- Change vertical anchor by grabbing handle. Set to values: Anchors max: 1, 0.07
	- Change Top coordinate to 0.
	- Add health slider to panel: UI -> Slider
		- Resize to fit left part of bar (adjust anchors)
		- Switch off "interactable"
		- Transition: None
		- Select sub-node: Handle Slide Area: Deactivate
		- Choose colours for slider background and fill area sub-nodes
	- Add score text: UI -> TextMeshPro
		- Align right by adjusting anchors
		- Font size:
			- Tick "Auto size"
			- Min-max: 5, 72
		- Alignment: Right, middle
	- Download font (e.g. from dafont.com)
		- Create Fonts folder in assets
		- Drag downloaded font into it
		- Window -> TextMeshPro -> Font Asset Creator
		- Drag font asset into "Source font file"
		- Click generate font atlas
		- Click Save (into fonts asset folder) and exit dialog
		- Select text
		- Drag created font asset into Font Asset
		- Outline effect:
			- Leave vertex colour unchanged
			- Scroll down to "Extra Settings"
			- Choose "Face Colour", low opacity
			- Choose "Outline colour", similar to face colour, full opacity
			- Set glow, same colour as above. Increase "inner"
		
UI - behaviour
	- Canvas: Add UiDisplay script
	- In the script, remember:
		- using UnityEngine.UI;
		- using TMPro;
	- Slider and text:
		[SerializeField] Slider m_slider;
		[SerializeField] TextMeshProUGUI m_scoreText;
	- Get health script from player object:
        Player player = FindObjectOfType<Player>();
        m_health = player.GetComponent<Health>();	
	-  m_slider.minValue = 0;
       m_slider.maxValue = m_health.GetHealth();s
	- Pad score with leading zeros:
		
Adding scenes:
	- Rename existing scene to Game
	- Prefab Background, AudioPlayer and ScoreKeeper
	- Scenes folder: Right-click -> Create -> Scene ->MainMenu
	- Open MainMenu scene by double-clicking it
	- Instantiate Background and AudioPlayer
	- Add canvas
		- Click on the newly created EventSystem node -> Click Replace with InputSystemUIInputModule
		(- As an example: On Canvas: Add button: Button TextMeshPro 
			- Image component has a colour
			- There are several colours in the Button component.
				- Image component Colour will take presedence if Normal Colour is white.
				  Choosing another Normal colour will blend with image colour
				- Others: Highlighted, pressed, selected, disabled
			- Delete button)
			
	- On Background, reduce move speed
	- Canvas: "Canvas Scaler", "Scale with screen size"
	- Duplicate font asset, "Menu Font"
		- Check "color gradient",
		- Check "Horizontal gradient", choose colours
		- Add "underlay" for 3D effect
		- Add glow
	- Create button
		- Set text -> Play
		- Set transparency on Image -> Color
		- "Button" component: Set normal, highlighted, selected colors
		- Duplicate button		
	- On Canvas, create empty ButtonGroup object
		- On ButtonGroup, add "Vertical Layout Group"
			- Move buttons within group
			- Set Spacing 
			- Check "Control Child Size", width and height
	- In scenes folder, duplicate MainMenu into GameOver scene
	
Level Manager:
	- File -> Build Settings: Scenes in Build
		- Only contains the start scene (Game). Build index is shown on the right
		- Drag the other scenes into the list
		- Drag MainMenu to the top
	- In MainMenu scene, create empty game object: LevelManager
	- Create LevelManager script
		- using UnityEngine.SceneManagement;
	- Prefab LevelManager
	- Start Button: Add OnClick event
		- Drag LevelManager to the event's object
		- Choose LevelManager -> LoadGame
	- Quit button: Add OnClick event
	
	- Switch to Game scene
	- Instantiate LevelManager
	- Health script:
		- Get ref to LevelManager
		- Load game over scene in Die method
		
	- Switch to GameOver scene
	- Instantiate LevelManager
		- Add Play button onclick event
		- Add Main Menu button onclick event
		
	- LevelManager: Delay loading of game over scene:
		IEnumerator WaitAndLoad(string sceneName, float delay)
		{
			yield return new WaitForSeconds(delay);
			SceneManager.LoadScene(sceneName);
		}
		
Play audio continuously via singleton:
	- AudioPlayer script. First version, not globally available:
		- Awake: ManageSingleton
		
		void ManageSingleton()
		{
			int instanceCount = FindObjectsOfType(GetType()).Length;
			if (instanceCount > 1)
			{
				gameObject.SetActive(false);
				Destroy(gameObject);
			}
			else
				DontDestroyOnLoad(gameObject);
		}		
		
	- Second version, via Singleton:
	
		static AudioPlayer s_instance;
		
        if (s_instance != null)
        {
            gameObject.SetActive(false);
            Destroy(gameObject);
        }
        else
        {
            s_instance = this;
            DontDestroyOnLoad(gameObject);
        }
		
Transfer score from Game to GameOver scene:
	- In GameOver: New script, UIGameOver. Add to Canvas
		- Fetch ScoreKeeper and set score from it
	- Make ScoreKeeper a singleton, same approach as for AudioPlayer
	- Reset score when starting new game from GameOver scene:
		- LevelManager: Fetch ScoreKeeper and call ResetScore() in LoadGame()
	- Instantiate ScoreKeeper in MainMenu scene
	
Build game for various platforms:
	- File -> Build settings
	- WebGL:
		- Player -> Resolution and presentation: Set canvas resolution
		- Player -> Publishing Settings: Compression format: Disabled
	- ShareMyGame.com
	